#!/bin/sh

# SHCOPYRIGHT

#RCFILE=${FSLDIR}/etc/fslconf/fsl_sub.cfg
RCFILE=/usr/local/share/fsl_sub/cfg
. $RCFILE

usage ()
{
  cat <<EOF

fsl_sub V1.0beta - wrapper for job control system such as SGE

Usage: fsl_sub [options] <command>

fsl_sub gzip *.img *.hdr
fsl_sub -q short.q gzip *.img *.hdr
fsl_sub -a darwin regscript rawdata outputdir ...

  -q <queuename>        Possible values for <queuename> are "verylong.q", "long.q" 
                        and "short.q". See below for details
                        Default is "long.q".
  -a <arch-name>        Architecture [darwin or lx24-amd64]
  -p <job-priority>     Lower priority [0:-1024] default = 0                 
  -M <email-address>    Who to email, default = `whoami`@fmrib.ox.ac.uk 
  -j <jid>              Place a hold on this task until job jid has completed
  -t <filename>         Specify a task file of commands to execute in parallel
  -N <jobname>          Specify jobname as it will appear on queue
  -v                    Verbose mode.

Queues:

There are three batch queues configured on the cluster, each with defined CPU
time limits.

short.q:    This queue is for jobs which last less then 2h. There are two slots 
            per node.
long.q:     This queue is for jobs which last less than 24h. There are two slots
            per node.
verylong.q: This queue is for jobs which will take longer than 24h CPU time.
            There is one slot per node, and jobs on this queue have a nice value
            of 5. If jobs enter the short.q queue then items running on this
            queue are suspended and resumed on completion of the short.q task.

EOF

  exit 1
}

nargs=$#
if [ $nargs -eq 0 ] ; then
  usage
fi

set -- `getopt q:a:p:M:j:t:N:v $*`
result=$?
if [ $result != 0 ] ; then
  echo "What? Your arguments make no sense!"
fi

if [ $nargs -eq 0 ] || [ $result != 0 ] ; then
  usage
fi

queue=long.q
mailto=`whoami`@fmrib.ox.ac.uk

while [ $1 != -- ] ; do
  case $1 in
    -q)
      queue=$2
      shift;;
    -a)
      sge_arch="-l arch=$2"
      shift;;
    -p)
      sge_priority="-p $2"
      shift;;
    -M)
      mailto=$2
      shift;;
    -j)
      jid=$2
      sge_hold="-hold_jid $jid"
      shift;;
    -t)
      taskfile=$2
      tasks=`wc -l $taskfile | awk '{print $1}'`
      sge_tasks="-t 1-$tasks"
      shift;;
    -N)
      JobName=$2;
      shift;;
    -v)
      verbose=1
      ;;
  esac
  shift  # next flag
done

shift

if [ "x$JobName" == x ] ; then 
    JobName=`basename $1`
fi

if [ "x$tasks" != x ] && [ ! -f "$taskfile" ] ; then
    echo $taskfile: invalid input!
    echo Should be a text file listing all the commands to run!
    exit -1
fi

if [ "x$tasks" != "x" ] && [ "x$@" != "x" ] ; then
    echo $@
    echo Spurious input after parsing command line!
    exit -1
fi

case $METHOD in

    SGE)
	if [ "x$tasks" == "x" ] ; then
	    sge_command="qsub -V -cwd -shell n -b y -r y -q $queue -M $mailto -N $JobName -m ase $sge_arch $sge_hold $sge_tasks"
	    if [ x$verbose != x ] ; then 
		echo sge_command: $sge_command
		echo executing: $@
	    fi
	    exec $sge_command $@ | awk '{print $3}'
	else
	    sge_command="qsub -V -cwd -q $queue -M $mailto -N $JobName -m ase $sge_arch $sge_hold $sge_tasks"
	    if [ x$verbose != x ] ; then 
		echo sge_command: $sge_command
		echo control file: $taskfile
	    fi
	    exec $sge_command <<EOF | awk '{print $3}' | awk -F. '{print $1}'
#!/bin/sh

#$ -cwd -q $queue
#$ -S /bin/sh
#$ -V
#$ -m as

command=\`sed -n -e "\${SGE_TASK_ID}p" $taskfile\`

exec /bin/sh -c "\$command"
EOF
	fi
	;;

    HOSTLIST)
	if [ "x$tasks" == "x" ] ; then
	    if [ x$verbose != x ] ; then 
		echo executing: $@
	    fi
	    # wait for any job holds to complete
	    if [ "x$jid" != x ] ; then
		echo Waiting for $jid
	        while [ -f ${SPOOLDIR}/$jid ] ; do
		    sleep 2
		done
	    fi
	    # pick a host to execute the command and
	    # start job on it
	    next_job
	    echo $host >> ${SPOOLDIR}/${njid}
	    if [ $host == LOCAL ] ; then
		nohup /usr/local/bin/fsl_sub_shepherd `pwd` $njid $@ &
	    else
		ssh $host nohup /usr/local/bin/fsl_sub_shepherd `pwd` $njid $@ &
	    fi
	    echo $njid
	else
	    if [ x$verbose != x ] ; then 
		echo Running commands in: $taskfile
	    fi
	    # wait for any job holds to complete
	    if [ "x$jid" != x ] ; then
		echo Waiting for $jid
	        while [ -f ${SPOOLDIR}/$jid ] ; do
		    sleep 2
		done
	    fi

	    # for each line of the control file
	    n=1
	    while [ $n -le $tasks ] ; do
		line=`sed -n -e ''${n}'p' $taskfile`
		# pick host
		# start job on host
		next_job
		echo $host >> ${SPOOLDIR}/${njid}
		if [ $host == LOCAL ] ; then
		    nohup /usr/local/bin/fsl_sub_shepherd `pwd` $njid $line &
		else
		    ssh $host nohup /usr/local/bin/fsl_sub_shepherd `pwd` $njid $line &
		fi
		echo $njid
		n=`expr $n + 1`
	    done
	fi	
	;;

esac

